/**
 * MathForge - Universal Mathematical Code Generator
 * Core generation engine with template management
 */

import type {
	FormalSpec,
	GeneratedCode,
	GenerationOptions,
	GenerationStats,
	Operation,
	TargetLanguage,
	TemplateContext,
	TypeDefinition,
} from "../types/spec.js";

/**
 * Template helper functions for code generation
 */
export const templateHelpers = {
	capitalize: (str: string): string => str.charAt(0).toUpperCase() + str.slice(1),

	camelCase: (str: string): string =>
		str.replace(/[-_\s]+(.)?/g, (_, c) => (c ? c.toUpperCase() : "")),

	snakeCase: (str: string): string =>
		str
			.replace(/([A-Z])/g, "_$1")
			.toLowerCase()
			.replace(/^_/, ""),

	pascalCase: (str: string): string => {
		const camel = templateHelpers.camelCase(str);
		return templateHelpers.capitalize(camel);
	},

	formatType: (type: string, language: TargetLanguage): string => {
		switch (language) {
			case "typescript":
				return type.replace(/Result<(.+)>/, "Either<QiError, $1>");
			case "python":
				return type.replace(/Result<(.+)>/, "Result[$1, QiError]");
			case "haskell":
				return type.replace(/Result<(.+)>/, "Either QiError $1");
			default:
				return type;
		}
	},

	formatComment: (comment: string, language: TargetLanguage): string => {
		switch (language) {
			case "typescript":
				return `// ${comment}`;
			case "python":
				return `# ${comment}`;
			case "haskell":
				return `-- ${comment}`;
			default:
				return comment;
		}
	},
};

/**
 * Main code generator class
 */
export class MathForgeGenerator {
	private readonly spec: FormalSpec;
	private readonly options: GenerationOptions;
	private readonly context: TemplateContext;

	constructor(spec: FormalSpec, options: GenerationOptions) {
		this.spec = spec;
		this.options = options;
		this.context = {
			spec,
			options,
			helpers: templateHelpers,
		};
	}

	/**
	 * Generate code for the specified language
	 */
	async generate(): Promise<GeneratedCode> {
		const _startTime = performance.now();

		try {
			const mainCode = await this.generateMainCode();
			const testCode = this.options.include_tests ? await this.generateTestCode() : undefined;
			const benchmarkCode = this.options.include_benchmarks
				? await this.generateBenchmarkCode()
				: undefined;
			const documentation = this.options.include_documentation
				? await this.generateDocumentation()
				: undefined;

			const dependencies = this.extractDependencies();
			const metadata = this.generateMetadata(mainCode, testCode, benchmarkCode);

			return {
				language: this.options.target_language,
				main_code: mainCode,
				test_code: testCode,
				benchmark_code: benchmarkCode,
				documentation: documentation,
				dependencies,
				metadata,
			};
		} catch (error) {
			throw new Error(`Code generation failed: ${error}`);
		}
	}

	/**
	 * Generate main implementation code
	 */
	private async generateMainCode(): Promise<string> {
		switch (this.options.target_language) {
			case "typescript":
				return this.generateTypeScript();
			case "python":
				return this.generatePython();
			case "haskell":
				return this.generateHaskell();
			default:
				throw new Error(`Unsupported language: ${this.options.target_language}`);
		}
	}

	/**
	 * Generate TypeScript implementation
	 */
	private generateTypeScript(): string {
		const { metadata, operations, type_definitions } = this.spec;

		return `/**
 * ${metadata.component} - Generated by MathForge
 * Mathematical Foundation: ${metadata.mathematical_foundation}
 * Package Strategy: ${metadata.package_strategy}
 * Laws Verified: ${metadata.laws_verified.join(", ")}
 */

${this.generateTypeScriptImports()}

${this.generateTypeScriptTypes(type_definitions)}

${this.generateTypeScriptOperations(operations)}

${this.generateTypeScriptExports()}
`;
	}

	/**
	 * Generate Python implementation
	 */
	private generatePython(): string {
		const { metadata, operations, type_definitions } = this.spec;

		return `"""
${metadata.component} - Generated by MathForge
Mathematical Foundation: ${metadata.mathematical_foundation}
Package Strategy: ${metadata.package_strategy}
Laws Verified: ${metadata.laws_verified.join(", ")}
"""

${this.generatePythonImports()}

${this.generatePythonTypes(type_definitions)}

${this.generatePythonOperations(operations)}
`;
	}

	/**
	 * Generate Haskell implementation
	 */
	private generateHaskell(): string {
		const { metadata, operations, type_definitions } = this.spec;

		return `{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}

-- | ${metadata.component} - Generated by MathForge
-- Mathematical Foundation: ${metadata.mathematical_foundation}
-- Package Strategy: ${metadata.package_strategy}
-- Laws Verified: ${metadata.laws_verified.join(", ")}

module ${templateHelpers.pascalCase(metadata.component)} where

${this.generateHaskellImports()}

${this.generateHaskellTypes(type_definitions)}

${this.generateHaskellOperations(operations)}
`;
	}

	/**
	 * Generate TypeScript imports
	 */
	private generateTypeScriptImports(): string {
		const target = this.spec.generation_targets.typescript;
		const imports: string[] = [];

		if (target.formal_verification_tools.includes("zod")) {
			imports.push("import { z } from 'zod';");
		}
		if (target.formal_verification_tools.includes("fast-check")) {
			imports.push("import * as fc from 'fast-check';");
		}
		if (target.package_dependencies.includes("fp-ts")) {
			imports.push("import { Either, left, right, isLeft, isRight } from 'fp-ts/Either';");
		}

		return imports.join("\n");
	}

	/**
	 * Generate Python imports
	 */
	private generatePythonImports(): string {
		const target = this.spec.generation_targets.python;
		const imports: string[] = [];

		imports.push("from typing import Any, Callable, TypeVar");

		if (target.formal_verification_tools.includes("pydantic")) {
			imports.push("from pydantic import BaseModel");
		}
		if (target.formal_verification_tools.includes("hypothesis")) {
			imports.push("from hypothesis import given, strategies as st");
		}
		if (target.package_dependencies.includes("returns")) {
			imports.push("from returns.result import Result, Success, Failure");
		}

		return imports.join("\n");
	}

	/**
	 * Generate Haskell imports
	 */
	private generateHaskellImports(): string {
		const target = this.spec.generation_targets.haskell;
		const imports: string[] = [];

		if (target.formal_verification_tools.includes("quickcheck")) {
			imports.push("import Test.QuickCheck");
		}

		imports.push("import Data.Either (Either(..), isLeft, isRight)");

		return imports.join("\n");
	}

	/**
	 * Generate TypeScript type definitions
	 */
	private generateTypeScriptTypes(types: Record<string, TypeDefinition>): string {
		return Object.entries(types)
			.map(([name, def]) => {
				const params = def.type_parameters ? `<${def.type_parameters.join(", ")}>` : "";
				const fields = def.fields?.map((field) => `  ${field}: any;`).join("\n") || "";
				return `interface ${name}${params} {\n${fields}\n}`;
			})
			.join("\n\n");
	}

	/**
	 * Generate Python type definitions
	 */
	private generatePythonTypes(types: Record<string, TypeDefinition>): string {
		return Object.entries(types)
			.map(([name, def]) => {
				const params = def.type_parameters ? `[${def.type_parameters.join(", ")}]` : "";
				const fields = def.fields?.map((field) => `    ${field}: Any`).join("\n") || "";
				return `class ${name}${params}:\n${fields || "    pass"}`;
			})
			.join("\n\n");
	}

	/**
	 * Generate Haskell type definitions
	 */
	private generateHaskellTypes(types: Record<string, TypeDefinition>): string {
		return Object.entries(types)
			.map(([name, def]) => {
				const params = def.type_parameters ? ` ${def.type_parameters.join(" ")}` : "";
				const constructors = def.constructors?.join(" | ") || "()";
				return `data ${name}${params} = ${constructors}`;
			})
			.join("\n");
	}

	/**
	 * Generate TypeScript operations
	 */
	private generateTypeScriptOperations(operations: Record<string, Operation>): string {
		return Object.entries(operations)
			.map(([opName, op]) => {
				const comment = `/**\n * ${op.description}\n * ${op.signature}\n */`;
				const impl = `function ${opName}(/* implementation */): any {\n  // ${op.semantics}\n  throw new Error("Not implemented");\n}`;
				return `${comment}\n${impl}`;
			})
			.join("\n\n");
	}

	/**
	 * Generate Python operations
	 */
	private generatePythonOperations(operations: Record<string, Operation>): string {
		return Object.entries(operations)
			.map(([opName, op]) => {
				const comment = `"""${op.description}\n${op.signature}"""`;
				const impl = `def ${opName}():\n    """${op.semantics}"""\n    raise NotImplementedError("Not implemented")`;
				return `${comment}\n${impl}`;
			})
			.join("\n\n");
	}

	/**
	 * Generate Haskell operations
	 */
	private generateHaskellOperations(operations: Record<string, Operation>): string {
		return Object.entries(operations)
			.map(([opName, op]) => {
				const comment = `-- ${op.description}\n-- ${op.signature}`;
				const impl = `${opName} :: ${op.signature}\n${opName} = error "Not implemented"`;
				return `${comment}\n${impl}`;
			})
			.join("\n\n");
	}

	/**
	 * Generate TypeScript exports
	 */
	private generateTypeScriptExports(): string {
		const operations = Object.keys(this.spec.operations);
		return `\nexport { ${operations.join(", ")} };`;
	}

	/**
	 * Generate test code
	 */
	private async generateTestCode(): Promise<string> {
		switch (this.options.target_language) {
			case "typescript":
				return this.generateTypeScriptTests();
			case "python":
				return this.generatePythonTests();
			case "haskell":
				return this.generateHaskellTests();
			default:
				return "";
		}
	}

	/**
	 * Generate TypeScript tests
	 */
	private generateTypeScriptTests(): string {
		return `/**
 * ${this.spec.metadata.component} Tests - Generated by MathForge
 */

import { describe, it, expect } from 'bun:test';
import * as fc from 'fast-check';

describe('${this.spec.metadata.component} Tests', () => {
  // Generated property tests would go here
  it('should satisfy mathematical laws', () => {
    expect(true).toBe(true); // Placeholder
  });
});
`;
	}

	/**
	 * Generate Python tests
	 */
	private generatePythonTests(): string {
		return `"""
${this.spec.metadata.component} Tests - Generated by MathForge
"""

import pytest
from hypothesis import given, strategies as st

class Test${templateHelpers.pascalCase(this.spec.metadata.component)}:
    """Generated property tests"""
    
    def test_mathematical_laws(self):
        """Test mathematical law compliance"""
        assert True  # Placeholder
`;
	}

	/**
	 * Generate Haskell tests
	 */
	private generateHaskellTests(): string {
		return `-- | ${this.spec.metadata.component} Tests - Generated by MathForge

module ${templateHelpers.pascalCase(this.spec.metadata.component)}Spec where

import Test.QuickCheck
import ${templateHelpers.pascalCase(this.spec.metadata.component)}

-- Generated property tests would go here
prop_mathematical_laws :: Bool
prop_mathematical_laws = True -- Placeholder
`;
	}

	/**
	 * Generate benchmark code
	 */
	private async generateBenchmarkCode(): Promise<string> {
		return `// Benchmark code for ${this.spec.metadata.component}
// Generated by MathForge
// TODO: Implement performance benchmarks
`;
	}

	/**
	 * Generate documentation
	 */
	private async generateDocumentation(): Promise<string> {
		return `# ${this.spec.metadata.component} Documentation

Generated by MathForge

## Mathematical Foundation
${this.spec.metadata.mathematical_foundation}

## Package Strategy  
${this.spec.metadata.package_strategy}

## Operations
${Object.entries(this.spec.operations)
	.map(([name, op]) => `### ${name}\n${op.description}\n\n**Signature:** \`${op.signature}\``)
	.join("\n\n")}
`;
	}

	/**
	 * Extract dependencies from generation targets
	 */
	private extractDependencies(): string[] {
		const target = this.spec.generation_targets[this.options.target_language];
		return [...target.package_dependencies, ...target.formal_verification_tools];
	}

	/**
	 * Generate metadata about the generated code
	 */
	private generateMetadata(
		mainCode: string,
		testCode?: string,
		_benchmarkCode?: string
	): GeneratedCode["metadata"] {
		const countLines = (code: string) => code.split("\n").length;
		const _countOperations = Object.keys(this.spec.operations).length;
		const countProperties = Object.values(this.spec.operations).reduce(
			(sum, op: Operation) => sum + Object.keys(op.properties || {}).length,
			0
		);

		return {
			lines_of_code: countLines(mainCode),
			test_count: testCode ? countLines(testCode) : 0,
			property_count: countProperties,
			law_count: this.spec.metadata.laws_verified.length,
		};
	}
}

/**
 * Generate code from specification
 */
export async function generateCode(
	spec: FormalSpec,
	options: GenerationOptions
): Promise<GeneratedCode> {
	const generator = new MathForgeGenerator(spec, options);
	return generator.generate();
}

/**
 * Generate statistics about the generation process
 */
export function generateStats(
	specFile: string,
	result: GeneratedCode,
	generationTime: number
): GenerationStats {
	return {
		spec_file: specFile,
		target_language: result.language,
		generation_time_ms: generationTime,
		total_lines: result.metadata.lines_of_code + (result.metadata.test_count || 0),
		operations_generated: Object.keys(result.metadata).length,
		properties_generated: result.metadata.property_count,
		tests_generated: result.metadata.test_count,
		laws_verified: [], // Would extract from spec
	};
}
